# 面试题

### 热更新原理

webpack 的热更新主要是利用 webpack-dev-server 插件, 实现模块热替换, 只需要局部刷新页面上变化的模块, 同时可以保留当前页面的状态, 比如输入框的输入.

具体实现步骤:

- 启动 webpack, 生成 compiler 实例, compiler 上面有很多方法, 比如监听文件改变、 启动 webpack 所有的编译工作
- 开启本地服务, 使浏览器可以请求本地资源
- 开启一个 websocket, 建立本地服务和浏览器的双向通信, 已实现监听到文件改变, 立马告知浏览器可以更新代码
- JSONP 获取到最新的代码 (JSONP 获取的代码可以直接执行)
- hotUpdate 找到旧模块, \_\_webpack_require\_\_执行新增模块的代码

### 大文件上传(分片、断点续传)

> 参考链接: [https://juejin.im/post/6844903860327186445](https://juejin.im/post/6844903860327186445)

- 分片
  - 前端将文件进行分片<br />
    前端分片是基于文件的 slice 方法, 该方法是 File 对象继承自 Blob 对象的一个方法, 可以对二进制文件进行拆分
  - 后端对分片进行还原
    - 确认说有切片均上传完毕 (可以通过一个接口来通知上传完毕, 服务端可以开始还原)
    - 增加一个 context 参数, 用来标识切片来源于同一文件
    - 增加一个索引参数, 用来标明切片的顺序
    - 按顺序拼接切片, 还原成文件
- 断点续传<br />
  断点续传是指可以从已经上传的部分开始继续上传未上传的部分, 而没有必要从头开始上传, 节省上传时间. 实现步骤:
  - 每个切片上传成功后保存已上传的切片信息
    - 已上传切片信息的保存可以存在本地或是从服务端读取. 本地的话, 快但是清空之后会丢失上传记录. 服务端是不会丢失记录, 但是慢
  - 下次上传相同文件时, 遍历保存的切片列表, 只选择未上传的切片进行上传
  - 所有切片上传完毕, 调用 mkFile 接口通知服务端进行文件合并
- 上传进度
  - 通过监听[xhr.upload](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload)的 progress 事件, 可以实现监控每一个切片的上传进度
- 上传暂停
  - 通过 xhr.abort 方法, 取消未完成上传切片的上传

### 文件上传的四种方式

- 普通表单上传
  - 通过指定表单提交的内容类型为 enctype='multiple/form-data', 表明表单需要上传二进制数据
- iframe 无刷新页面
  - 正常的表单提交, 会进行页面跳转, 这是 form 表单的 target 属性造成的, 其取值有:
    - \_self
    - \_blank
    - \_parent
    - \_top
    - frameName
  - 通过 frameName 把 target 指定为一个隐藏的 iframe, 来实现只有 iframe 刷新, 页面无刷新的效果. 至于返回结果, 可以通过解析这个 iframe 内的文本来获取
- 文件编码上传
  - base64 后上传, 通常体积会比源文件要大
- formData 异步上传
  - 通过 XMLHttpRequest 对象发起的 ajax 请求, 模拟 form 表单提交

### 两个超精度字符串数字的求和

### setState 是异步的吗

在 componentDidMount 中, setState 和 setTimeout(() => {}, 0) 哪个先执行

### 移动端适配

### head 标签中有哪些标签, 常用的移动端 meta 标签有哪些

### 微前端中, 不同子应用命名空间如何避免同名 (沙盒)
