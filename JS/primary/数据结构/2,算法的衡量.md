# 算法的衡量
正常情况下, 我们评价一个人是否懂行, 一个重要的一句就是看这个人是否有对这个事物的评价能力. 在算法中, 我们评价的两个重要依据就是: 时间复杂度、空间复杂度.

### 时间复杂度
我们可以通过一个方法中代码的执行次数, 来反应这个方法执行所需要耗费的时间. 但是具体的去计算方法中代码的执行次数T(n), 这件事做起来就比较麻烦. 所以, 我们一般回去看变化趋势, 就是随着输入规模的增加, 这个算法执行总次数的一个变化趋势. 这种就比较简单直接, 一眼可见. 

总结: 算法中的时间复杂度, 指的是随着输入规模的增加, 算法中执行总次数的一个变化趋势.

- 例子:
```js
function traverse1(arr) {
    const n = arr.length
    for(let i=0; i<n; i++) {
        console.log(arr[i])
    }
}
```
这个长度为n的一维数组遍历时, 最内的循环体执行的次数是n次, 所以它的时间复杂度是O(n)

```js
function traverse2(arr) {
    const n = arr.length
    for(let i=0; i<n; i++) {
      const m = arr[i].length;
        for (let j = 0; j < m; j++) {
          console.log(arr[i][j])
        }
    }
}
```
这个长度为n * m的二维数组遍历时, 最内的循环体执行的次数是n * m次, 所以它的时间复杂度是O(n * m)

常见的时间复杂度, 除了上面这种简单的多项式外, 还有logn:
```js
function traverse1(arr) {
    const n = arr.length
    for(let i = 1; i < n; i = i * 2) {
        console.log(arr[i])
    }
}
```
这种的话, 每次的变化都是一种跳跃式的, 跳跃的规则是: 从1开始, 每次下标乘以2. 数学化计算出执行次数为: 2 ^ x < n; 得出 x > log2(n). 这里2应该是下标, 即以2为底n的对数. 将底数和系数进行简化, 可以得出大O表示法的时间复杂度为logn.

- 常见的时间复杂度, 从小到大的顺序排列, 有以下几种:

| 常数时间 | 对数时间 | 线性时间 | 线性对数时间 | 二次时间 | 三次时间 | 指数时间 |
| -------- | -------- | -------- | ------------ | -------- | -------- | -------- |
| O(1)     | O(logn)  | O(n)     | O(nlogn)     | o(n^2)   | o(n^3)   | o(2^n)   |


### 空间复杂度
空间复杂度是对一个算法, 在运行过程中临时暂用存储空间大小的一个度量. 和时间复杂度类似, 他是内存的一个增长趋势.

常见的空间复杂度有: O(1), O(n), O(n^2)

- 例子:
```js
const traverse = (arr) => {
  const len = arr.length;
  for(let i = 0; i < len; i++) {
    console.log(arr[i])
  }
}
```
在上述遍历中, 占有空间的有这些变量: len, arr, i. 循环体在执行时, 并没有开辟新的内存空间, 因此traverse函数对内存的占用量是恒定的, 他对应的空间复杂度就是O(1)

```js
const init = (n) => {
  let arr = []
  for(let i = 0; i < n; i++) {
    arr[i] = i;
  }
  return arr;
}
```
上面是一个初始化数组的方法, 里面占用内存的变量: n, arr, i. 这里arr并不是一成不变的, arr的大小会随着n的大小增大而增大, 呈一个线性的变化, 所以它的空间复杂度为O(n).

由此不难想象, 初始化一个规模为n * n的二维数组, 空间复杂度为 O(n^2).
